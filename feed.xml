<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://lambdaxing.github.io/</id><title>LambdaXing's Website</title><subtitle>Notes and Blogs</subtitle> <updated>2021-08-21T00:05:48+08:00</updated> <author> <name>lambdaxing</name> <uri>https://lambdaxing.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://lambdaxing.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="https://lambdaxing.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator> <rights> © 2021 lambdaxing </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>Effective Modern C++ - notes</title><link href="https://lambdaxing.github.io/posts/Effective-Modern-Cpp/" rel="alternate" type="text/html" title="Effective Modern C++ - notes" /><published>2021-02-03T18:00:00+08:00</published> <updated>2021-07-28T17:15:51+08:00</updated> <id>https://lambdaxing.github.io/posts/Effective-Modern-Cpp/</id> <content src="https://lambdaxing.github.io/posts/Effective-Modern-Cpp/" /> <author> <name>lambdaxing</name> </author> <category term="Notes" /> <category term="Cpp" /> <summary>   《Effecive Modern C++》（中文版）阅读笔记的风格同《More Effective C++》。以我自己的情况进行记录，并将个别术语换成了我理解的偏大陆词汇，比如，将型别换为类型。不过在看习惯之后，我发现型别这个词也挺不错的。 Chapter 1. Deducing Types Item 1: Understand template type deduction   函数模板的类型推导中，编译器通过 expr 推导两个类型：T 和 ParamType，ParamType 常包含一些饰词，如 const 或引用符号等限定词。 template&amp;lt;typename T&amp;gt; void f(ParamType param); // 调用 f(expr); 当 ParamType 是指针（T* 、const T*）或引用（T&amp;amp; 、const ... </summary> </entry> <entry><title>More Effective C++ - notes</title><link href="https://lambdaxing.github.io/posts/More-Effective-Cpp/" rel="alternate" type="text/html" title="More Effective C++ - notes" /><published>2021-01-14T22:49:00+08:00</published> <updated>2021-01-14T22:49:00+08:00</updated> <id>https://lambdaxing.github.io/posts/More-Effective-Cpp/</id> <content src="https://lambdaxing.github.io/posts/More-Effective-Cpp/" /> <author> <name>lambdaxing</name> </author> <category term="Notes" /> <category term="Cpp" /> <summary>   前一个月看了《Effective C++》，边看边抄了份笔记，看完后感觉很过瘾，打算接着看《More Effective C++》，本来不打算写笔记了，但看到第一章就发现了值得记录的东西。不过这次我只记要点、结论，在此基础上按情况添加。毕竟笔记只是笔记，仅作复盘来用，原版内容仍然值得多读，尽管从导读部分就能感受到此书年代久远。   这本书的爸爸写它时，其兄弟《Effevtive C++》第三版还没出生，原文中有一些对其兄弟（第二版）内容的引用，形如 E1、E2，我在叙述时对其做了更新，指涉第三版中对应的条款。 一. 基础议题 01 仔细区别 pointers 和 references   使用 pointers 的时机：当你需要考虑 “不指向任何对象” 的可能性以及考虑 “在不同时间指向不同对象” 的能力时。前者，你可以将 pointer 设为 nullptr，后者是指针本... </summary> </entry> <entry><title>Effective C++ - notes</title><link href="https://lambdaxing.github.io/posts/Effective-Cpp/" rel="alternate" type="text/html" title="Effective C++ - notes" /><published>2020-12-02T20:00:00+08:00</published> <updated>2021-07-23T22:32:35+08:00</updated> <id>https://lambdaxing.github.io/posts/Effective-Cpp/</id> <content src="https://lambdaxing.github.io/posts/Effective-Cpp/" /> <author> <name>lambdaxing</name> </author> <category term="Notes" /> <category term="Cpp" /> <summary>   这是一份我在阅读《Effective C++》过程中记录的笔记，也仅仅只是笔记。其中大部分内容节选自原文，少部分内容由我自己叙述和添加。   公开阅读笔记似乎是一种对原作的侵权行为，但看到很多人写过类似的笔记，我不太清楚这是否属于 “有法必依，执法必严”。如有侵权，请联系我删除。如有错误或不当之处，欢迎大家指正，谢谢！ 零. Introduction   在选择点上做出正确决定很重要，因为一个不良的决定有可能不至于很快带来影响，却在发展后期才显现恶果，那时候再来矫正往往即困难又耗时间，而且代价昂贵。   软件设计和实现是复杂的差使，被硬件、操作系统、应用程序的约束条件涂上五颜六色，这儿仅提供指南，让你得以创造出更棒的程序。惟有了解条款背后的基本原理，你才能够决定是否将它套用于你所开发的软件，并奉行其所昭示的独特约束。 一. Accustoming Yourself to C... </summary> </entry> <entry><title>C++ - virtual function</title><link href="https://lambdaxing.github.io/posts/Cpp-virtual-function/" rel="alternate" type="text/html" title="C++ - virtual function" /><published>2020-10-08T17:16:00+08:00</published> <updated>2020-10-08T17:16:00+08:00</updated> <id>https://lambdaxing.github.io/posts/Cpp-virtual-function/</id> <content src="https://lambdaxing.github.io/posts/Cpp-virtual-function/" /> <author> <name>lambdaxing</name> </author> <category term="Notes" /> <category term="Cpp" /> <summary> 简述   虚函数，用于定义类型特定行为的成员函数。   在 c++ 语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。基类希望它的派生类各自定义某些函数，使其适合自身，此时基类就将这些函数声明成虚函数。   动态绑定只作用于虚函数，并且需要通过指针或引用调用。动态绑定在运行时根据引用或指针所绑定的对象的实际类型来选择执行虚函数的某一个版本。当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。   我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。   基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参和返回类型必须与派生类中的形参和返回类型严格匹配。例外是，当类的虚函数返回类型是类本身的指针或引用，且从派生类到基类的类型转... </summary> </entry> <entry><title>C++ - class-type conversions</title><link href="https://lambdaxing.github.io/posts/Cpp-class-type-conversions/" rel="alternate" type="text/html" title="C++ - class-type conversions" /><published>2020-10-07T19:27:00+08:00</published> <updated>2021-02-04T02:12:04+08:00</updated> <id>https://lambdaxing.github.io/posts/Cpp-class-type-conversions/</id> <content src="https://lambdaxing.github.io/posts/Cpp-class-type-conversions/" /> <author> <name>lambdaxing</name> </author> <category term="Notes" /> <category term="Cpp" /> <summary>   只接受单独一个实参的非显式构造函数定义了从实参类型到类类型的隐式类型转换；而非显式的类型转换运算符则定义了从类类型到其他类型的隐式转换。转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversions），也被称作用户定义的类型转换（user-defined conversions）。 类型转换运算符   类型转换运算符（conversion operator）是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示： operator type() const { }   type是某种类型（除了 void之外），该类型能作为函数的返回类型（不允许数组或函数类型，但允许指针（数组指针及函数指针）或者引用类型）。类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算... </summary> </entry> </feed>
