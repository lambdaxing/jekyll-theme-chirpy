[ { "title": "Effective Modern C++ - notes", "url": "/posts/Effective-Modern-Cpp/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2021-02-03 18:00:00 +0800", "snippet": "  《Effecive Modern C++》（中文版）阅读笔记的风格同《More Effective C++》。以我自己的情况进行记录，并将个别术语换成了我理解的偏大陆词汇，比如，将型别换为类型。不过在看习惯之后，我发现型别这个词也挺不错的。Chapter 1. Deducing TypesItem 1: Understand template type deduction  函数模板的类型推导中，编译器通过 expr 推导两个类型：T 和 ParamType，ParamType 常包含一些饰词，如 const 或引用符号等限定词。template&amp;lt;typename T&..." }, { "title": "More Effective C++ - notes", "url": "/posts/More-Effective-Cpp/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2021-01-14 22:49:00 +0800", "snippet": "  前一个月看了《Effective C++》，边看边抄了份笔记，看完后感觉很过瘾，打算接着看《More Effective C++》，本来不打算写笔记了，但看到第一章就发现了值得记录的东西。不过这次我只记要点、结论，在此基础上按情况添加。毕竟笔记只是笔记，仅作复盘来用，原版内容仍然值得多读，尽管从导读部分就能感受到此书年代久远。  这本书的爸爸写它时，其兄弟《Effevtive C++》第三版还没出生，原文中有一些对其兄弟（第二版）内容的引用，形如 E1、E2，我在叙述时对其做了更新，指涉第三版中对应的条款。一. 基础议题01 仔细区别 pointers 和 references  使..." }, { "title": "Effective C++ - notes", "url": "/posts/Effective-Cpp/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-12-02 20:00:00 +0800", "snippet": "  这是一份我在阅读《Effective C++》过程中记录的笔记，也仅仅只是笔记。其中大部分内容节选自原文，少部分内容由我自己叙述和添加。  公开阅读笔记似乎是一种对原作的侵权行为，但看到很多人写过类似的笔记，我不太清楚这是否属于 “有法必依，执法必严”。如有侵权，请联系我删除。如有错误或不当之处，欢迎大家指正，谢谢！零. Introduction  在选择点上做出正确决定很重要，因为一个不良的决定有可能不至于很快带来影响，却在发展后期才显现恶果，那时候再来矫正往往即困难又耗时间，而且代价昂贵。  软件设计和实现是复杂的差使，被硬件、操作系统、应用程序的约束条件涂上五颜六色，这儿仅提供..." }, { "title": "C++ - virtual function", "url": "/posts/Cpp-virtual-function/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-10-08 17:16:00 +0800", "snippet": "简述  虚函数，用于定义类型特定行为的成员函数。  在 c++ 语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。基类希望它的派生类各自定义某些函数，使其适合自身，此时基类就将这些函数声明成虚函数。  动态绑定只作用于虚函数，并且需要通过指针或引用调用。动态绑定在运行时根据引用或指针所绑定的对象的实际类型来选择执行虚函数的某一个版本。当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。  我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。  基类中的虚函数在派生类中隐含地..." }, { "title": "C++ - class-type conversions", "url": "/posts/Cpp-class-type-conversions/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-10-07 19:27:00 +0800", "snippet": "  只接受单独一个实参的非显式构造函数定义了从实参类型到类类型的隐式类型转换；而非显式的类型转换运算符则定义了从类类型到其他类型的隐式转换。转换构造函数和类型转换运算符共同定义了类类型转换（class-type conversions），也被称作用户定义的类型转换（user-defined conversions）。类型转换运算符  类型转换运算符（conversion operator）是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示： operator type() const { }  type是某种类型（除了 void之外），该类..." }, { "title": "C++ - overloaded operator", "url": "/posts/Cpp-overloaded-operator/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-10-07 11:03:00 +0800", "snippet": "基本概念  当运算符作用于类类型的对象时，c++语言允许我们为其指定新的含义。重载的运算符是具有特殊名字的函数：它们的名字由关键字 operator 和其后要定义的运算符号共同组成。重载的运算符也包含返回类型、参数列表以及函数体。  一个重载的运算符必须是某个类的成员或者至少拥有一个类类型的运算对象。重载运算符的运算对象数量、结合律、优先级与对应的用于内置类型的运算符完全一致。当运算符被定义为成员时，类对象的隐式 this 指针绑定到第一个运算对象。赋值、下标、函数调用和箭头运算符必须作为类的成员。  通常情况下，我们可以直接调用一个重载的运算符函数（通过函数名字）。我们不应该重载逗号、..." }, { "title": "C++ - callable object", "url": "/posts/Cpp-callable-object/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-10-07 10:38:00 +0800", "snippet": "简述  C++语言中有几种可调用对象：函数、函数指针、lambda 表达式、bind 创建的对象以及重载了函数调用运算符的类。  可调用对象也有类型，例如：每个 lambda 有它自己唯一的（未命名）的类类型；函数及函数指针的类型则由其返回类型和实参类型决定，等等。  两个不同类型的可调用对象却可能共享同一种调用形式（call signature）。调用形式指明了调用返回的类型以及传递给调用的实参类型。一种调用形式对应一个函数类型，例如： int(int, int);标准库 function 类型  有时候，我们希望几个具有同一种调用形式的可调用对象能被看成具有相同的类型。例如，在..." }, { "title": "C++ - class - move", "url": "/posts/Cpp-class-move/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-10-04 14:46:00 +0800", "snippet": "前述  很多情况下会发生对象的拷贝，在其中的某些情况中，对象拷贝后就立即被销毁了，此时移动对象而非拷贝对象会大幅度提升性能。重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。IO类或 unique_ptr 这样的类都包含不能被共享的资源，它们不能拷贝但可以移动。右值引用  右值引用（rvalue reference）就是必须绑定到右值的引用。我们通过 &amp;amp;&amp;amp; 来获得右值引用，它只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。  左值和右值是表达式的属性，一个左值表达式表示的是一个对..." }, { "title": "C++ - class - copy", "url": "/posts/Cpp-class-copy/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-10-04 10:53:00 +0800", "snippet": "copy constructor  copy constructor 的第一个参数是自身类类型的引用，且任何额外参数都有默认值。第一个参数必须是一个引用类型（在函数调用过程中，非引用类型的参数要进行拷贝初始化，参数不是引用类型，调用就会无效套娃下去。），几乎总是一个 const 的引用，拷贝构造函数在几种情况下会隐式地使用（比如向函数传递或从函数返回非引用，隐含了拷贝），通常不应该是 explicit 的。 合成的 copy constructor：  没有定义拷贝构造函数，即使定义了其他构造函数，编译器也会合成一个拷贝构造函数。合成的拷贝构造函数会将其参数的成员逐个拷贝到正在..." }, { "title": "C++ - summary of copy control", "url": "/posts/Cpp-summary-of-copy-control/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-10-03 18:16:00 +0800", "snippet": "前述  当定义一个类时，我们显式或隐式地指定此类型的对象拷贝、移动、赋值和销毁时做什么。通过五种特殊的成员函数来控制这些操作：拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。这些操作被称为拷贝控制..." }, { "title": "C++ - destructor", "url": "/posts/Cpp-destructor/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-10-03 16:10:00 +0800", "snippet": "destructor 简述  析构函数释放对象使用的资源，并销毁对象的非 static 数据成员。析构函数的名字由波浪号接类名构成，它没有返回值，也不接受参数。对于一个给定类，只会有唯一一个析构函数。  析构函数有一个函数体和一个析构部分。与构造函数相反，在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。通常，析构函数释放对象在生存期分配的所有资源。析构部分是隐式的，成员销毁时依赖于成员的类型，类类型需要执行成员自己的析构函数，内置类型什么也不需要做。注意：隐式销毁一个内置指针类型的成员不会 delete 它所指向的对象。 智能指针在析构阶段会自动销毁。什么时候..." }, { "title": "C++ - constructor", "url": "/posts/Cpp-constructor/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-10-03 12:11:00 +0800", "snippet": "constructor 简述  类通过构造函数（constructor）来控制其对象的初始化过程，只要类的对象被创建，就会执行构造函数。构造函数的名字和类名相同，没有返回类型，不能被声明成 const，因为只有在构造函数完成初始化过程，const 对象才能真正取得其“常量”属性。未显式定义构造函数的类，编译器会隐式地定义一个合成的默认构造函数，这个合成的默认构造函数按如下规则初始化类的数据成员： 如果存在类内的初始值，用它来初始化成员。 否则，默认初始化该成员。（默认值由数据成员的类型决定，内置类型和复合类型（数组和指针）的值被默认初始化（在块内）将是未定义的，类类型的成员没有默认构..." }, { "title": "C++ - name lookup", "url": "/posts/Cpp-name-lookup/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-10-02 21:55:00 +0800", "snippet": "普通的名字查找  名字查找（name lookup）：寻找与所用名字最匹配的的声明的过程。 首先，在名字所在块中寻找，只考虑在名字的使用之前出现的声明。 如果未找到，继续查找外层作用域。 如果最终未找到匹配的声明，则程序报错。类的名字查找  声明之后定义之前的类是一个不完全类型（incomplete type），可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。  一旦一个类的名字出现后就被认为时声明过了，类的定义分两步处理： 首先，编译成员的声明。 直到类全部可见后才编译函数体。  编译器处理完类中的全部声明后才会处理成员函数..." }, { "title": "C++ - smart pointer", "url": "/posts/Cpp-smart-pointer/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-09-28 20:55:00 +0800", "snippet": "  静态内存用来保存局部 static 对象、类 static 数据成员以及定义在任何函数之外的变量。栈内存用来保存定义在函数内的非 static 对象。分配在静态内存或栈内存中的对象由编译器自动创建和销毁。除了静态内存和栈内存，每个程序还拥有一个内存池，这部分内存被称为自由空间（ free store ）或堆（ heap ）。程序用堆来存储动态分配（ dynamically allocate ）的对象。标准库提供了智能指针（ smart pointer ）类型来管理动态对象，负责自动释放所指向的对象，它们都定义在头文件 memory 中。shared_ptr op..." }, { "title": "C++ - lambda and bind", "url": "/posts/Cpp-lambda-and-bind/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-09-28 20:00:00 +0800", "snippet": "lambda  lambda 是一种可调用对象，可对其使用调用运算符。一个 lambda 表达式表示一个可调用的代码单元，我们可以将其理解为一个未命名的内联函数。lambda 表达式具有如下形式： [capture list](parameter list) -&amp;gt; return type { function body }  可以忽略 parameter list 和 return type ，但必须包含 capture list 和 function body 。如果 lambda 的函数体只是一个 return 语句，则返回类型可从返回的表达式类型推断而来。如果函..." }, { "title": "C++ - auto and decltype", "url": "/posts/Cpp-auto-and-decltype/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-09-25 20:55:00 +0800", "snippet": "auto   auto 让编译器通过初始值来推算变量的类型，auto 在一条语句中声明多个变量时，该语句中所有变量的初始基本数据类型都必须一样。编译器会适当地改变初始值的结果类型使其更符合初始化规则： 引用被用作初始值时，编译器以引用对象的类型作为 auto 的类型。 auto 一般会忽略掉顶层 const ，保留底层 const 。若要推断出顶层 const 需明确指出。 设置一个类型为 auto 的引用时，初始值中的顶层常量属性仍然保留。 int i = 0; const int ci = i, &amp;amp;cr = ci; auto b = ci; ..." }, { "title": "C++ - const", "url": "/posts/Cpp-const/", "categories": "Notes, Cpp", "tags": "Cpp", "date": "2020-09-24 20:55:00 +0800", "snippet": "  const 是 C++ 非常重要的一个特性，虽然平时使用得比较多，但是重新回去看书才发现一些概念性的东西很容易遗忘了，特整理记录一下。1. const  有时候需要这样一种变量，它的值不能被改变，使用它的地方不少，当我们要对其进行调整时很容易修改，但也要随时警惕防止程序修改这个值。为满足这一要求，可用关键字 const 对变量的类型加以限定: const int bufSize = 512; // 输入缓冲区大小  编译器将在编译过程中把用到变量bufSize的地方都替换成对应的值 512 。const 对象的值一经创建就不能再改变，所以必须初始化，同时只能在 c..." }, { "title": "DataStructure -- Array and Chain", "url": "/posts/DataStructure-Array-Chain/", "categories": "Blogs, DataStructure", "tags": "DataStructure", "date": "2020-09-22 20:55:00 +0800", "snippet": "  数组和链表可以说是最为基础的数据结构，分别代表了两种数据结构的存储方式（顺序存储 和 链式存储）。  一个数组的每一个实例都是形如（索引，值）的数对集合，其中任意两个数对的索引都不相同。数组是大部分语言的标准数据结构，其模型类似下图：有关数组的操作: 取值： 对一个给定的索引，取对应位置上的值。 存值： 将新值存入给定索引标识的位置。  数组存储于内存上一片连续的空间中，通过索引我们可以很容易在 O(1) 内实现随机访问。但是数组的内存空间是一次性分配的，扩容操作需要分配更大的空间，再将原数据拷贝到新空间中，时间复杂度是 O(n) 。由于连续紧凑的存储方式，插入和删除操作涉及拷贝..." } ]
