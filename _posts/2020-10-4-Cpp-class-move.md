---
title: C++ - class - move
author: lambdaxing
date: 2020-10-4 14:46:00 +0800
categories: [Notes, Cpp]
tags: [Cpp]
---

## 前述

&emsp;&emsp;很多情况下会发生对象的拷贝，在其中的某些情况中，对象拷贝后就立即被销毁了，此时移动对象而非拷贝对象会大幅度提升性能。重新分配内存的过程中，从旧内存将元素拷贝到新内存是不必要的，更好的方式是移动元素。IO类或 `unique_ptr` 这样的类都包含不能被共享的资源，它们不能拷贝但可以移动。

## 右值引用

&emsp;&emsp;右值引用（rvalue reference）就是必须绑定到右值的引用。我们通过 `&&` 来获得右值引用，它只能绑定到一个将要销毁的对象。因此，我们可以自由地将一个右值引用的资源“移动”到另一个对象中。  
&emsp;&emsp;左值和右值是表达式的属性，一个左值表达式表示的是一个对象的身份，而一个右值表达式表示的是对象的值。一个右值引用也是某个对象的另一个名字，我们不能将一个左值引用绑定到要求转换的表达式、字面值常量或是返回右值的表达式。右值引用有着完全相反的绑定特性：可以将一个右值引用绑定到这类表达式上，但不能将一个右值引用绑定到一个左值上。  
&emsp;&emsp;赋值、下标、解引用和前置递增/递减运算符返回左值的表达式；返回非引用类型的函数，连同算术、关系、位以及后置递增/递减运算符都生成右值，可以将一个 `const` 的左值引用或者一个右值引用绑定到这类表达上。很明显，左值有持久的状态，右值要么是字面常量，要么是在表达式求值过程中创建的临时对象。由于右值引用只能绑定到临时对象，所引用的对象将要被销毁，且该对象没有其他用户，使用右值引用的代码可以自由地接管（窃取）所引用的对象的资源。  
&emsp;&emsp;特别地，变量表达式都是左值（变量是持久的，直至离开作用域才销毁）。我们不能将一个右值引用绑定到一个右值引用类型的变量上，即：

```c++
    int &&rr1 = 42;     // 正确
    int &&rr2 = rr2;    // 错误：表达式 rr1 是左值！
```

## std::move()

&emsp;&emsp;虽然不能将一个右值引用直接绑定到一个左值上，但我们可以显式地将一个左值转换为对应的右值引用类型。通过调用一个名为 `move` 的标准库函数来获得绑定到左值上的右值引用，此函数定义在头文件 `utility` 中。`move` 告诉编译器：我们有一个左值，但我们希望像一个右值一样处理它。调用 `move` 就意味着承若：除了对其赋值或销毁它外，我们不再使用它。在调用 `move` 之后，我们不能对移后源对象的值做任何假设。

## move constructor and move-assignment operator

### 简述

&emsp;&emsp;如果我们自己的类也同时支持移动和拷贝，那么也能从中受益。可为我们自己的类型定义移动构造函数和移动赋值运算符。它们从给定对象“窃取”资源而不是拷贝资源。  
&emsp;&emsp;移动构造函数的第一个参数是该类类型的一个右值引用，任何额外的参数都必须有默认实参。除了完成资源移动，移动构造函数还必须确保移后源对象处于这样一个状态——销毁它是无害的。特别是，一旦资源完成移动，源对象必须不再指向被移动的资源——这些资源的所有权已经归属新创建的对象了。  
&emsp;&emsp;由于移动操作“窃取”资源，它通常不分配任何资源，因此，移动操作通常不会抛出任何异常。除非标准库知道元素类型的移动操作不会抛出异常，否则，它就必须使用对应的拷贝操作而不是移动操作。我们通过使用 `noexcept` 显式地告诉标准库我们的移动操作不抛出任何异常，可以安全使用。`noexcept` 是我们承若一个函数不抛出异常的一种方法，在一个函数的参数列表后指定 `noexcept`，且必须在类头文件的声明和定义中都指定 `noexcept`。

&emsp;&emsp;移动赋值运算符执行与析构函数和移动构造函数相同的工作，且必须：

+ 正确处理自赋值。
+ 确保移后源对象为可析构的状态。
+ 确保对象仍然有效，可以安全地为其赋予新值或可以安全使用而不依赖其当前值。
+ 用户不能对其值进行任何假设。

### 合成的移动操作

&emsp;&emsp;只有当一个类没有定义任何自己版本的拷贝控制成员，且每个类的非 `static` 数据成员都可以移动时，编译器才会为它合成移动构造函数和移动赋值运算符，编译器可以移动内置类型的成员。如果类定义了一个移动操作，则该类的合成拷贝操作会被定义为删除的。如果一个类没有移动操作，通过正常的函数匹配，类会使用对应的拷贝操作来替代移动操作。  
&emsp;&emsp;移动操作定义为删除的遵循的原则：

+ 显式要求编译器生成 `=default` ，且编译器不能移动所有类的成员。
+ 类成员定义了拷贝操作且未定义移动操作，或是有类成员未定义拷贝操作且编译器不能为其合成移动操作。
+ 类成员的移动操作被定义为删除的或不可访问的。
+ 类的析构函数被定义为删除的或不可访问的，则类的移动构造函数被定义为删除的。
+ 有类成员时 `const` 的或是引用，则类的移动赋值运算符被定义为删除的。

### 匹配

&emsp;&emsp;编译器使用普通的函数匹配规则来确定使用哪个操作（move or copy）：移动右值，拷贝左值。如果一个类没有移动操作，函数匹配保证该类型的对象会被拷贝，即使我们试图通过调用 `move` 来移动时也是如此。

## 移动迭代器

&emsp;&emsp;移动迭代器是标准库定义的一种移动迭代器适配器。它的解引用运算符返回一个右值引用。我们通过调用 `make_move_iterator` 函数将一个普通迭代器转换为一个移动迭代器。此函数接受一个迭代器参数，返回一个移动迭代器。原迭代器的所有其他操作在移动迭代器中都照常工作。我们可以将一对移动迭代器传递给算法，使其移动元素而不是拷贝元素，比如 `uninitialized_copy`。标准库不保证哪些算法适用移动迭代器，移动一个对象可能销毁掉原对象，只有在确信算法在为一个元素赋值或将其传递给一个用户定义的函数后不再访问它时，才能将移动迭代器传递给算法。

## 成员函数的 copy 和 move

&emsp;&emsp;除了构造函数和赋值运算符，成员函数也可以提供拷贝和移动版本从中受益。拷贝版本接受一个指向 `const` 的左值引用（`const T&`），移动版本接受一个指向非 `const` 的右值引用（`T&&`）。定义了 `push-back` 的标准库容器就提供了这两个版本。 当我们希望从实参“窃取”数据时，通常传递一个右值引用，实参不能是 `const` 的。类似的，从一个对象进行拷贝的操作不应该改变该对象，实参是 `const` 的。  
&emsp;&emsp;通常，我们在一个对象上调用成员函数，不管该对象是一个左值还是一个右值。为了向后兼容，允许向右值赋值，但是我们希望在自己的类中阻止这种做法，可以强制左侧运算对象（即 this 指向的对象）是一个左值。我们通过在参数列表后放置一个引用限定符来指出 this 的左值/右值属性（与定义 `const` 成员函数相同，必须同时出现在函数声明和定义中，引用限定符必须跟随在 `const` 限定符之后）：对于 `&` 限定的函数，我们只能将它用于左值；对于 `&&` 限定的函数，只能用于右值。  
&emsp;&emsp;引用限定符也可以区分重载版本，我们可以综合引用限定符和 `const` 来区分一个成员函数的重载版本。与 `const` 不同，如果一个成员函数有引用限定符，则具有相同参数列表的所有版本都必须有引用限定符。

---

## References

《 C++ Primer 5 》
