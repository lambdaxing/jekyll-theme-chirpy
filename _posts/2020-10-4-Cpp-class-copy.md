---
title: C++ - class - copy
author: lambdaxing
date: 2020-10-4 10:53:00 +0800
categories: [Notes, Cpp]
tags: [Cpp]
---

## copy constructor

&emsp;&emsp;copy constructor 的第一个参数是自身类类型的引用，且任何额外参数都有默认值。第一个参数必须是一个引用类型（在函数调用过程中，非引用类型的参数要进行拷贝初始化，参数不是引用类型，调用就会无效套娃下去。），几乎总是一个 `const` 的引用，拷贝构造函数在几种情况下会隐式地使用（比如向函数传递或从函数返回非引用，隐含了拷贝），通常不应该是 `explicit` 的。

+ 合成的 copy constructor：  
&emsp;&emsp;没有定义拷贝构造函数，即使定义了其他构造函数，编译器也会合成一个拷贝构造函数。合成的拷贝构造函数会将其参数的成员逐个拷贝到正在创建的对象中，编译器从给定对象中依次将每个非 `static` 成员拷贝到正在创建的对象中。每个成员的类型决定了它如何拷贝：内置类型直接拷贝，类类型成员使用其拷贝构造函数来拷贝，逐元素拷贝数组类型的成员，数组元素如何拷贝由其元素类型决定（向前套娃）。  
&emsp;&emsp;如果类的某个成员的拷贝构造函数是删除的或不可访问的，或者类的某个成员的析构函数是删除的或不可访问的，则类的合成拷贝构造函数被定义为删除的。

+ 拷贝初始化：  
&emsp;&emsp;直接初始化实际上是编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。拷贝初始化则求编译器将右侧运算对象拷贝到正在创建的对象中，**如果需要的话还要进行类型转换。** 拷贝初始化通常使用拷贝构造函数来完成，有时也会使用 move constructor。拷贝初始化在我们用 `=` 定义变量和以下情况时会发生：
  - 将一个对象作为实参传递给一个非引用类型的形参。
  - 从一个返回类型为非引用类型的函数返回一个对象。
  - 用花括号列表初始化一个数组中的元素或一个聚合类中的成员。

&emsp;&emsp;类类型对象还会对它们所分配的对象使用拷贝初始化。例如，标准库容器初始化或调用其 `insert` 和 `push` 成员时，容器会对其元素进行拷贝初始化，用 `emplace` 成员创建的元素都进行直接初始化。  
&emsp;&emsp;在拷贝初始化过程中（例如使用 `=`时），编译器可以（但不是必须）跳过拷贝/移动构造函数，直接（使用其他匹配的构造函数）创建对象。但在这个程序点上，拷贝/移动构造函数必须是存在且可访问的。

## copy-assignment operator

### 前瞻

&emsp;&emsp;与类控制其对象如何初始化一样，类也可以控制其对象如何赋值。类可以定义自己的拷贝赋值运算符（copy-assignment operator）和移动赋值运算符（move-assignment operator）。  
&emsp;&emsp;assignment operator 实际上是重载运算符，本质上是函数。重载运算符其名字由 `operator` 关键字后接表示要定义的运算符的符号组成。赋值运算符就是名为 `operator=` 的函数，有一个返回类型和一个参数列表（表示运算符的运算对象）。赋值运算符必须定义为成员函数，运算符左侧的运算对象绑定到隐式的 `this` 参数，右侧运算对象作为显式参数传递。为了与内置类型的赋值保持一致，赋值运算符通常返回一个指向其左侧运算对象的引用。标准库通常要求保存在容器中的类型要具有赋值运算符，且其返回值时左侧运算对象的引用。

### 简述

&emsp;&emsp;如果一个类未定义自己的拷贝赋值运算符，编译器会为它生成一个合成拷贝赋值运算符。它将右侧运算对象的每个非 `static` 成员赋予左侧运算对象的对应成员，这一工作通过成员类型的拷贝赋值运算符来完成。对于数组，会逐个赋值数组元素。合成拷贝赋值运算符返回一个指向其左侧运算对象的引用。  
&emsp;&emsp;如果类的某个成员的拷贝赋值运算符是删除的或不可访问的，或是有一个 **`const` 的或引用成员**，则类的合成拷贝赋值运算符被定义为删除的。

当编写行为像值的赋值运算符时，需注意：

+ 如果将一个对象赋予它自身，赋值运算符必须能正确工作。
+ 大多数赋值运算符组合了析构函数和构造函数的工作。

&emsp;&emsp;一个好的模式是，先将右侧运算对象拷贝到一个局部临时对象中。拷贝完成后，销毁左侧运算对象的现有成员（安全），之后将数据从临时对象拷贝到左侧运算对象的成员中。拷贝赋值运算符通常执行拷贝构造函数和析构函数中也要做的工作，应该将公共的工作放在 `private` 的工具函数中完成。赋值运算符必须处理自赋值！

---

## References

《 C++ Primer 5 》
