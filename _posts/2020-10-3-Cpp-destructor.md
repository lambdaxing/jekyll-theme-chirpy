---
title: C++ - destructor
author: lambdaxing
date: 2020-10-3 16:10:00 +0800
categories: [Notes, Cpp]
tags: [Cpp]
---

## destructor 简述

&emsp;&emsp;析构函数释放对象使用的资源，并销毁对象的非 `static` 数据成员。析构函数的名字由波浪号接类名构成，它没有返回值，也不接受参数。对于一个给定类，只会有唯一一个析构函数。  
&emsp;&emsp;析构函数有一个函数体和一个析构部分。与构造函数相反，在一个析构函数中，首先执行函数体，然后销毁成员，成员按初始化顺序的逆序销毁。通常，析构函数释放对象在生存期分配的所有资源。析构部分是隐式的，成员销毁时依赖于成员的类型，类类型需要执行成员自己的析构函数，内置类型什么也不需要做。**注意：隐式销毁一个内置指针类型的成员不会 `delete` 它所指向的对象。** 智能指针在析构阶段会自动销毁。

## 什么时候会调用 destructor

&emsp;&emsp;无论何时一个对象被销毁时，就会自动调用其析构函数：

+ 变量在离开其作用域时被销毁。
+ 当一个对象被销毁时，其成员被销毁。
+ 容器（标准库或数组）被销毁时，其元素被销毁。
+ 动态分配的对象，对指向它的指针应用 `delete` 时被销毁。
+ 对于临时对象，当创建它的完整表达式结束时被销毁。

&emsp;&emsp;注意：当指向一个对象的引用或指针离开作用域时，析构函数不会执行。

## 合成 destructor

&emsp;&emsp;当一个类未定义自己的析构函数时，编译器为它定义一个合成析构函数。合成析构函数的函数体为空，在（空）析构函数体执行完毕后，成员会被自动销毁。  
&emsp;&emsp;如果类的某个成员的析构函数是删除的或不可访问的，则类的合成析构函数和默认构造函数都被定义为删除的。

&emsp;&emsp;析构函数体自身并不直接销毁成员，成员是在析构函数体之后隐含的析构阶段中被销毁的。

## OOP 中的 destructor

&emsp;&emsp;基类通常应该定义一个虚析构函数，使得我们可以动态分配继承体系中的对象。当 `delete` 一个动态分配的对象的指针时将执行析构函数。如果该指针指向继承体系中的某个类型，则有可能出现指针的静态类型与被删除对象的动态类型不符的情况。和其他函数一样，我们通过在基类中将析构函数定义成虚函数以确保执行正确的析构函数版本。如果基类的析构函数不是虚函数，则 `delete` 一个指向派生类的对象的基类指针将产生未定义的行为。  
&emsp;&emsp;如果一个类定义了析构函数，即使它通过 `=default` 的形式使用了合成的版本，编译器也不会为这个类合成移动操作。  
&emsp;&emsp;和派生类的构造函数及赋值运算符不同，派生类的析构函数只负责销毁由派生类自己分配的资源。派生类对象的基类部分是自动销毁的。对象的销毁顺序与其创建的顺序相反；派生类析构函数首先执行，然后是基类的析构函数，以此类推，沿着继承体系的反方向直至最后。

---

## References

《 C++ Primer 5 》
