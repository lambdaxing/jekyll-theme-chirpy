---
title: C++ - summary of copy control
author: lambdaxing
date: 2020-10-3 18:16:00 +0800
categories: [Notes, Cpp]
tags: [Cpp]
---

## 前述

&emsp;&emsp;当定义一个类时，我们显式或隐式地指定此类型的对象拷贝、移动、赋值和销毁时做什么。通过五种特殊的成员函数来控制这些操作：**拷贝构造函数（copy constructor）、拷贝赋值运算符（copy-assignment operator）、移动构造函数（move constructor）、移动赋值运算符（move-assignment operator）和析构函数（destructor）**。拷贝和移动构造函数定义了当用同类型的另一个对象初始化本对象时做什么。拷贝和移动赋值运算符定义了将一个对象赋予同类型的另一个对象时做什么。析构函数定义了当此类型对象销毁时做什么。这些操作被称为**拷贝控制操作（copy control）**。  
&emsp;&emsp;如果一个类未声明这些操作，编译器会自动为其生成。如果这些操作未定义成删除的，它们会逐成员初始化、移动、赋值或销毁对象：合成的操作依次处理每个非 `static` 数据成员，根据成员类型确定如何移动、拷贝、赋值或销毁它。  
&emsp;&emsp;当一个类没有定义这些拷贝控制成员，编译器会自动为它定义缺失的操作。但对一些类来说，依赖这些操作的默认定义会导致灾难。我们需要认识到什么时候会需要定义这些操作。

## `=default` 和 `=delete`

&emsp;&emsp;通过将成员定义为 `=default` 来显式地要求编译器生成合成的constructor、copy-constructor、copy-assignment operator、destructor。  
&emsp;&emsp;对某些类来说，以上这些操作没有合理意义时，可采用某种机制阻止拷贝或赋值。通过将 copy-constructor 以及 copy-assignment operator 定义为删除的函数来阻止拷贝。在函数的参数列表后面加上 `=delete` 来指出它被定义为删除的。`=delete` 告诉编译器（以及代码的读者），我们不希望定义这些成员。`=delete` 必须出现在函数的第一次声明时（`=default` 可以出现在类外，直到编译器生成代码时才需要），以便编译器禁止试图使用它的操作。与 `=default` 不同，可以对任何函数指定 `=delete`，但是我们不应该删除析构函数。对于析构函数已删除的类型，不能定义该类型的变量或释放（意味着可动态分配）指向该类型动态分配对象的指针。

## 合成的 copy control 可能是删除的

&emsp;&emsp;值得注意的是，如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。当不可能拷贝、赋值或销毁类的成员时，类的合成拷贝控制成员就被定义为删除的。还有些显而易见的：

+ 一个成员有删除的或不可访问的析构函数会导致合成的默认和拷贝构造函数被定义为删除的；
+ 对于具有引用成员或无法默认构造的 `const` 成员的类，编译器不会为其合成默认构造函数；
+ 如果一个类有 `const` 成员,则它不能使用合成的拷贝赋值运算符；对于有引用成员的类，合成拷贝赋值运算符被定义为删除的，因为赋值改变的是引用指向的对象的值，而不是引用本身。

## 整体性

&emsp;&emsp;所有五个拷贝控制成员应该看做一个整体。分配了内存或其他资源的类需要拷贝资源，在特殊情况的下移动资源可以降低开销，销毁资源需要析构函数处理。  
&emsp;&emsp;分配了内存或其他资源的类几乎总是需要定义拷贝控制成员来管理分配的资源。合成的析构函数不会 `delete` 一个指针数据成员，合成的拷贝构造函数和拷贝赋值运算符简单拷贝指针成员，多个对象可能共享相同的内存。因此，如果一个类需要自定义析构函数，几乎可以肯定它也需要自定义拷贝赋值运算符和拷贝构造函数。需要拷贝构造操作的类也需要拷贝赋值操作，反之亦然。

## 其他

+ 拷贝并交换（copy and swap）：涉及赋值运算符的技术，首先拷贝右侧运算对象（发生在函数传参过程中的拷贝——拷贝构造新对象——副本），然后调用 swap 来交换（可正常移动，副本为临时对象）副本和左侧运算对象。

## OOP 中的 copy control

### 合成拷贝控制与继承

&emsp;&emsp;基类或派生类的合成拷贝控制成员的行为与其他合成的构造函数、赋值运算符或析构函数类似：它们对类本身的成员依次进行初始化、赋值或销毁的操作。合成的成员还负责使用直接基类中对应的操作对一个对象的直接基类部分进行初始化、赋值或销毁的操作。无论基类的对应成员是合成的版本还是自定义的版本，只要可访问且不是一个被删除的函数。

&emsp;&emsp;一些定义基类的方式可能导致有的派生类成员成为被删除的函数：

+ 如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的或者不可访问，则派生类中对应的成员将是被删除的，原因是编译器不能使用基类成员来执行派生类对象基类部分的构造、赋值或销毁操作。
+ 如果基类中有一个不可访问或删除掉的析构函数，则派生类中合成的默认和拷贝构造函数是被删除的，因为编译器无法销毁派生类对象的基类部分。
+ 如果基类中的析构函数或移动操作是被删除的或不可访问，则派生类的移动构造函数和对应的移动操作将是被删除的。

&emsp;&emsp;大多数基类都会定义一个虚析构函数，因此默认情况下，基类通常不含有合成的移动操作，则在它的派生类中也没有合成的移动操作。  
&emsp;&emsp;基类缺少移动操作会阻止派生类拥有自己的合成移动操作，当我们确实需要移动操作是应该首先在基类中定义。

### 派生类中拷贝控制成员

&emsp;&emsp;当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象。析构函数只负责销毁派生类自己分配的资源。我们通常使用对应的基类构造函数和赋值运算符为派生类对象的基类部分初始化和赋值。  
&emsp;&emsp;如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本。执行构造函数与析构函数，对象处于未完成的状态，调用虚函数应执行正在构造或析构的那个基类部分或派生类部分的虚函数版本。

---

## References

《 C++ Primer 5 》
