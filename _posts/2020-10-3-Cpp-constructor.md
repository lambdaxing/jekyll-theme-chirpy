---
title: C++ - constructor
author: lambdaxing
date: 2020-10-3 12:11:00 +0800
categories: [Notes, Cpp]
tags: [Cpp]
---

## constructor 简述

&emsp;&emsp;类通过构造函数（constructor）来控制其对象的初始化过程，只要类的对象被创建，就会执行构造函数。构造函数的名字和类名相同，没有返回类型，不能被声明成 `const`，因为只有在构造函数完成初始化过程，`const` 对象才能真正取得其“常量”属性。未显式定义构造函数的类，编译器会隐式地定义一个合成的默认构造函数，这个合成的默认构造函数按如下规则初始化类的数据成员：

+ 如果存在类内的初始值，用它来初始化成员。
+ 否则，默认初始化该成员。（**默认值由数据成员的类型决定，内置类型和复合类型（数组和指针）的值被默认初始化（在块内）将是未定义的，类类型的成员没有默认构造函数则编译器无法初始化该成员**）

&emsp;&emsp;编译器在类内不包含任何构造函数时，才会为我们生成一个默认构造函数，我们可以通过在不接受任何实参的构造函数后面写上 `= default` 来要求编译器合成默认构造函数。如果类包含有内置类型或复合类型的成员，只有当这些成员全都被赋予了类内的初始值时，这个类才适合使用合成的默认构造函数，否则就应该使用构造函数初始值列表初始化类的每个成员。当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化，即通过相应的类内初始值初始化（如果存在）或默认初始化。  
&emsp;&emsp;随着构造函数体一开始执行，类内数据成员的初始化就完成了。构造函数的初始值列表显式地初始化成员，**在构造函数体执行之前未被初始化的成员将执行默认初始化**。构造函数体内的成员赋值操作与初始化的差异有时候可以忽略（这儿的赋值一般是先初始化后再被赋值），但当成员是 `const`或引用或属于某个未定义默认构造函数的类类型时，必须将其初始化，最好的方式就是通过构造函数初始值列表为它们提供初值。  
&emsp;&emsp;成员的初始化顺序与它们在类定义中出现的顺序的一致，构造函数初始值列表初始值的前后位置关系不会影响实际的初始化顺序。最好令构造函数初始值的顺序与成员声明的顺序保持一致，避免使用某些成员初始化其他成员。  
&emsp;&emsp;一个为所有参数都提供了默认实参的构造函数，实际上也定义了默认构造函数。  
&emsp;&emsp;委托构造函数，使用它所属类的其他构造函数执行初始化构造，把它自己的一些或全部职责委托给了其他构造函数。受委托的构造函数先执行，然后执行委托者的构造函数。

## 默认构造函数的作用

&emsp;&emsp;当对象被**默认初始化**或**值初始化**时自动执行默认构造函数。

默认初始化：

+ 块作用域内无任何初始值定义一个非静态变量或数组时。

+ 当一个类含有类类型的成员且使用合成的默认构造函数时，该成员被默认初始化。

+ 类类型成员没有在构造函数初始值列表中显式地初始化时。

值初始化：

+ 数组初始化过程中提供的初始值数量少于数组的大小时。

+ 未使用初始值定义一个局部静态变量时。

+ 书写形如 `T()` 的表达式显式地请求值初始化时。（T 是类型名）

&emsp;&emsp;类必须包含一个默认构造函数以便在上述情况下使用。定义了其他构造函数，最好也提供一个默认构造函数。  
&emsp;&emsp;定义使用默认构造函数初始化的对象时，应去掉对象名之后的空括号对：

```c++
    Sales_data obj();       // 错误：声明了一个函数而非对象
    Sales_data obj2;        // 正确
```

注意：如果类的某个成员的析构函数是删除的或不可访问的，或是类有一个引用成员，它没有类内初始化器，或是有一个 `const` 成员，它没有类内初始化器且其类型未显式定义默认构造函数，则该类的默认构造函数被定义为删除的。

## 隐式的类类型转换

&emsp;&emsp;能通过一个实参调用的构造函数定义了一条从构造函数的参数类型向类类型隐式转换的规则，这种构造函数称为**转换构造函数**（converting constructor）。记住：编译器只会自动执行一步类型转换。  
&emsp;&emsp;通过将构造函数声明为 `explicit` 可阻止构造函数定义的隐式转换，编译器将不会在自动转换过程中使用该构造函数。只能在类内声明构造函数时使用 `explicit` 关键字，在类外部定义时不应重复。注意：**我们只能以直接初始化的形式使用 `explicit` 声明的构造函数。**  
&emsp;&emsp;虽然 `explicit` 构造函数不能用于隐式转换，但我们可以使用 `explicit` 的构造函数显式地进行强制转换， `static_cast` 可以使用 `explicit` 的构造函数进行转换。

## 其他

+ **[copy constructor](https://lambdaxing.github.io/posts/C++-class-copy/#copy-constructor)**
+ **[move constructor](https://lambdaxing.github.io/posts/C++-class-move/#move-constructor-and-move-assignment-operator)**

## OOP 中的 constructor

&emsp;&emsp;派生类能够重用其直接基类定义的构造函数。一个类只初始化它的直接基类，也只继承其直接基类的构造函数。类不能继承默认、拷贝和移动构造函数。如果派生类没有直接定义这些构造函数，编译器将为派生类合成它们。  
&emsp;&emsp;派生类继承基类构造函数的方式是提供了一条注明了（直接）基类名的 `using` 声明语句。通常情况下，`using` 声明语句只是令某个名字在当前作用域可见。而当作用于构造函数时，`using` 声明语句将领编译器产生代码。对于基类的每个构造函数，编译器都生成一个与之对应的派生类构造函数。这些编译器生成的构造函数刑如：

```c++
    derived(parms) : base(args) { }
```

其中，`derived` 是派生类的名字，`base` 是基类的名字，`parms` 是构造函数的形参列表，`args` 将派生类构造函数的形参传递给基类的构造函数。如果派生类含有自己的数据成员，则这些成员将被默认初始化。一个构造函数的 `using` 声明不会改变该构造函数的访问级别。不管 `using` 出现在哪，基类的私有构造函数在派生类中还是一个私有构造函数，`protected` 和 `public` 同样如此。一个 `using` 声明也不能指定 `explicit` 或者 `constexpr`，继承的构造函数拥有与基类相同的属性。  
&emsp;&emsp;含有默认实参的基类构造函数，其实参不会被继承。派生类将获得多个继承的构造函数，其中每个构造函数分别省略一个含有默认实参的形参。  
&emsp;&emsp;如果派生类定义的构造函数与基类的构造函数具有相同的参数列表，则该构造函数将不会被继承。定义在派生类中的构造函数将替换继承而来的构造函数。默认、拷贝和移动构造函数不会被继承。这些构造函数按照正常的规则被合成。

---

## References

《 C++ Primer 5 》
