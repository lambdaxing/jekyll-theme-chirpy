---
title: C++ - class-type conversions
author: lambdaxing
date: 2020-10-7 19:27:00 +0800
categories: [Notes, Cpp]
tags: [Cpp]
---

&emsp;&emsp;只接受单独一个实参的非显式构造函数定义了从实参类型到类类型的隐式类型转换；而非显式的类型转换运算符则定义了从类类型到其他类型的隐式转换。[转换构造函数](https://lambdaxing.github.io/posts/Cpp-constructor/#隐式的类类型转换)和类型转换运算符共同定义了类类型转换（class-type conversions），也被称作用户定义的类型转换（user-defined conversions）。

## 类型转换运算符

&emsp;&emsp;类型转换运算符（conversion operator）是类的一种特殊成员函数，它负责将一个类类型的值转换成其他类型。类型转换函数的一般形式如下所示：

```c++
    operator type() const { }
```

&emsp;&emsp;`type`是某种类型（除了 `void`之外），该类型能作为函数的返回类型（不允许数组或函数类型，但允许指针（数组指针及函数指针）或者引用类型）。类型转换运算符既没有显式的返回类型，也没有形参，而且必须定义成类的成员函数。类型转换运算符通常不应该改变待转换对象的内容，一般被定义为 `const` 成员。  
&emsp;&emsp;尽管编译器一次只能执行一个用户定义的类型转换，但是隐式的用户定义类型转换可以置于一个标准（内置）类型转换之前或之后，并与其一起使用。类型转换运算符是隐式执行的，所以无法给这些函数传递实参。尽管类型转换函数不负责指定返回类型，但实际上每个类型转换函数都会返回一个对应类型（`type`）的值。  
&emsp;&emsp;如果在类类型和转换类型之间不存在明显的映射关系，则这样的类型转换可能具有误导性。此时，定义一个或多个普通的成员函数以从各种不同形式中提取所需的信息是一种更好的方案。例外情况是，定义向 `bool` 的类型转换是比较普遍的。

&emsp;&emsp;类型转换运算符可能产生意外结果。为了防止意外情况，可以使用显式的类型转换运算符。

```c++
    explicit operator type() const { }
```

&emsp;&emsp;和显式的构造函数一样，编译器通常也不会将一个显式的类型转换运算符用于隐式类型转换。此时，必须通过显式的强制类型转换才可以执行类型转换。但是如果表达式被用作条件，则编译器会将显式的强制类型转换自动应用于它，即显式的类型转换将被隐式地执行。向 `bool` 的类型转换通常用在条件部分，因此 `operator bool`  一般定义成 `explicit` 的。

## 避免有二义性的类型转换

&emsp;&emsp;如果类中包含一个或多个类型转换，则必须确保在类类型和目标类型之间只存在唯一一种转换方式。否则的话，我们编写的代码将很可能会具有二义性。

+ 两个类定义了相同的类型转换。如 A 类定义了一个接受 B 类对象的转换构造函数，同时 B 类定义了一个转换目标是 A 类的类型转换运算符，它们提供了相同的类型转换。使用强制类型转换也无法解决此二义性问题，因为强制类型转换本身也面临二义性。
+ 类定义了多个转换规则，而这些转换涉及的类型本身可以通过其他类型转换联系在一起。例如，当类当中定义了转换目标都是算术类型的类型转换运算符时，编译器很多时候无法确定哪种算术类型的转换更好，因此相关调用会产生二义性。

&emsp;&emsp;通常情况下，不要为类定义相同的类型转换，也不要在类中定义两个及以上转换源或转换目标是算术类型的转换。  
&emsp;&emsp;当我们使用两个用户定义的类型转换时，如果转换函数之前或之后存在标准类型转换，则标准类型转换将决定最佳匹配到底是哪个。因此，算术类型容易在此产生二义性。

&emsp;&emsp;设计类的重载运算符、转换构造函数及类型转换函数必须加倍小心，尤其是当类同时定义了类型转换运算符及重载运算符（ +、-、... ）时，以下是一些经验准则：

+ 不要令两个类执行相同的类型转换。
+ 避免转换目标是内置算术类型的类型转换。当定义了一个转换成算术类型的类型转换时：
  - 不要再定义接受算术类型的重载运算符。替代方法：使用类型转换操作转换你的类型的对象，然后再使用内置的运算符完成该重载运算符的功能。
  - 让标准类型转换完成向其他算术类型转换的工作，而不是定义转换到其他多种算术类型的转换。
+ 总之，除了显式地向 `bool` 类型的转换之外，我们应该尽量避免定义类型转换函数，并尽可能地限制那些“显然正确”的非显式构造函数。

&emsp;&emsp;当我们调用重载的函数时，从多个类型转换中进行选择（形参与实参的匹配，实参具有多种类型转换）将变得更加复杂。如果两个或多个类型转换都提供了同一种**可行匹配**，则这些类型转换一样好。在这个过程中，不会考虑任何可能出现的标准类型转换的级别，只要当重载函数能通过同一个类型转换函数得到匹配时，我们才会考虑其中出现的标准类型转换。即，当调用重载函数所请求的（参数）用户定义的类型转换不止一个且彼此不同，该调用具有二义性。即使其中一个调用需要额外的标准类型转换而另一个调用能精确匹配，编译器也会将该调用标识为错误。

&emsp;&emsp;注意：**如果我们对同一个类即提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题。**

---
**There's a screenshot from [Mooophy/Cpp-Primer](https://github.com/Mooophy/Cpp-Primer/blob/master/ch14/README.md#exercise-1451)**
![array_img](/assets/img/2020-10-7-C++-overloaded-operator/review_order.png)

## OOP 中的类类型转换

&emsp;&emsp;在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，而且我们也能将基类的指针（包括智能指针类）或引用绑定到派生类对象中的基类部分。这种转换通常称为派生类到基类（derived-to-base）的类型转换。和其他类型转换一样，编译器会隐式地执行派生类到基类的转换。  
&emsp;&emsp;不存在从基类向派生类的隐式类型转换，即使一个基类指针或引用绑定在一个派生类对象上，我们也不能执行从基类向派生类的转换。这是因为编译器无法确定某个特定的转换在运行时是否安全，编译器只能通过检查指针或引用的静态类型来推断该转换是否合法。如果我们已知某个基类向派生类的转换是安全的，可以使用 `static_cast` 来强制覆盖掉编译器的检查工作。  
&emsp;&emsp;派生类向基类的自动转换只对指针或引用有效，在派生类类型和基类类型之间不存在这样的转换。注意，当我们初始化或赋值一个类类型的对象时，实际上是在调用某个函数。这些成员（构造函数或赋值运算符）通常都包含一个参数，其类型是类类型的 `const` 版本的引用。这些成员接受引用作为参数，所以**派生类向基类的转换允许我们给基类的拷贝/移动操作传递一个派生类的对象**。这些操作不是虚函数，当我们给基类的构造函数传递一个派生类对象时，实际运行的构造函数是基类中定义的那个，显然该构造函数只能处理基类自己的成员。类似的，赋值运算符也是一样。在这些过程中，派生类对象的派生类部分被忽略掉了。

---

## References

《 C++ Primer 5 》
