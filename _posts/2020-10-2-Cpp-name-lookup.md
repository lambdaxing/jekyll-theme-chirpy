---
title: C++ - name lookup
author: lambdaxing
date: 2020-10-2 21:55:00 +0800
categories: [Notes, Cpp]
tags: [Cpp]
---

## 普通的名字查找

&emsp;&emsp;名字查找（name lookup）：寻找与所用名字最匹配的的声明的过程。

+ 首先，在名字所在块中寻找，只考虑在名字的使用之前出现的声明。
+ 如果未找到，继续查找外层作用域。
+ 如果最终未找到匹配的声明，则程序报错。

## 类的名字查找

&emsp;&emsp;声明之后定义之前的类是一个不完全类型（incomplete type），可以定义指向这种类型的指针或引用，也可以声明（但是不能定义）以不完全类型作为参数或者返回类型的函数。  
&emsp;&emsp;一旦一个类的名字出现后就被认为时声明过了，类的定义分两步处理：

+ 首先，编译成员的声明。
+ 直到类全部可见后才编译函数体。

&emsp;&emsp;编译器处理完类中的全部声明后才会处理成员函数的定义，因此这种两阶段的处理方式只适用于成员函数（体）中使用的名字。声明中使用的名字（返回类型、参数列表）都必须在使用前确保可见。如果某个成员的声明使用了类中尚未出现的名字，则编译器将会在定义该类的作用域中继续查找。  
&emsp;&emsp;在类中不能重新定义（覆盖）外层作用域中某个代表一种类型的名字，重新定义类型名字是一种错误行为，编译器并不为此负责。类型名的定义通常出现在类的开始处，确保所有使用该类型的成员都出现在类型名的定义之后。

&emsp;&emsp;成员函数中的名字查找：

+ 首先，在成员函数内（名字前）查找该名字的声明。
+ 上一步未找到，则在类内继续查找，这时类的所有成员都可以被考虑。
+ 上一步（类内）未找到名字的声明，在成员函数**定义**之前的作用域内继续查找。（当成员定义在类的外部时，类定义之前的全局作用域中的声明和在成员函数定义之前的全局作用域中的声明都要考虑，即包括了成员函数出现之前的全局作用域）

## 友元的名字查找

&emsp;&emsp;当把类 A 的成员函数 a 声明为类 B 的一个友元时，类 A 的成员函数 a 必须在类 B 之前被声明，却不能定义它。因为在成员函数 a 内要使用类 B 的成员，所以必须先声明定义类B（包括对成员函数 a 的友元声明）。接下来才能定义成员函数 a，此时它才能使用类 B 的成员。示例代码如下：

```c++
#include <iostream>
#include <vector>
class B;
class A
{
    std::vector<B> elements;
public:
    void a(int);
};
extern B b;         // it's ok.
class B
{
    friend void A::a(int);
    int element = 0;
    static int e;
};
int B::e = 1;
void A::a(int i)
{
    while(elements.size() <= i)
        elements.push_back(B());
    std::cout << elements[i].element << std::endl;
}
int main()
{
    A x;
    x.a(2);
}
```

&emsp;&emsp;我们隐式地假定第一次出现在一个友元声明中的名字在当前作用域中是可见的，但该名字并不一定真的声明在当前作用域中。友元声明的作用是影响访问权限，并非普通意义上的声明，必须在类的外部提供相应的声明从而使得函数（被声明为友元的）可见。

## OOP 中的名字查找

&emsp;&emsp;当类存在继承关系时，派生类的作用域嵌套在其基类的作用域之内。如果一个名字在派生类的作用域内无法正确解析，则编译器将继续在外层的基类作用域中寻找该名字的定义。  
&emsp;&emsp;一个对象、引用或指针的静态类型决定了该对象的哪些成员是可见的。即使静态类型与动态类型可能不一致（当使用基类的引用或指针时会发生这种情况），但是我们能使用的哪些成员仍然是由静态类型决定的。比如，使用基类指针的时候，对其成员的搜索将从该基类开始，而其派生类的成员将不会在搜索范围中。  
&emsp;&emsp;和其他作用域一样，派生类也能重新定义在其基类或间接基类中的名字，此时定义在内层作用域（即派生类）的名字将隐藏定义在外层作用域（即基类）的名字。我们可以通过作用域运算符来使用一个被隐藏的基类成员。除了覆盖继承而来的虚函数之外，派生类最好不要重用其他定义在基类中的名字。

假定我们调用 `p->mem()`（或者 `obj.mem()`），将依次执行以下4个步骤：

+ 首先确定 `p` （或 `obj`）的静态类型。
+ 在 `p` （或 `obj`）的静态类型对应的类中查找 `mem`。如果找不到，则依次在直接基类中不断查找直至到达继承链的顶端。如果找遍了该类及其基类仍然找不到，则编译器将报错。
+ 一旦找到了 `mem`，就进行常规的类型检查以确认对于当前找到的 `mem`，本次调用是否合法。
+ 假设调用合法，则编译器根据调用的是否是虚函数而产生不同的代码：
  - 如果 `mem` 是虚函数且我们是通过引用或指针进行的调用，则编译器产生的代码将在运行时确定到底运行虚函数的哪个版本，依据是对象的动态类型。
  - 反之，如果 `mem` 不是虚函数或者我们是通过对象（而非引用或指针）进行的调用，则编译器将产生一个常规函数调用。

&emsp;&emsp;记住：名字查找先于类型检查。声明在内层作用域的函数并不会重载声明在外层作用域的函数。因此，定义在派生类中的函数也不会重载其基类中的成员。如果派生类（即内层作用域）的成员与基类（即外层作用域）的某个成员同名，则派生类将在其作用域内隐藏该基类成员。**即使派生类成员和基类成员的形参列表不一致，基类成员也仍然会被隐藏**。  
&emsp;&emsp;假如基类与派生类的虚函数接受的实参不同，则我们就无法通过基类的引用或指针调用派生类的虚函数了。因为名字查找先与类型检查，找到了该名字后，再进行类型检查，若不是虚函数且参数不匹配，编译器将报错，基类（即外层作用域）的名字根本不会被找到。  
&emsp;&emsp;所以说，要想基类中的某个名字（成员函数）可见，我们要么覆盖该名字的所有版本，要么一个也不覆盖。我们可以为重载的成员提供一条 `using` 声明语句，它指定一个名字而不指定形参列表，所以一条基类成员函数的 `using` 声明语句就可以把该函数的所有重载实例添加到派生类作用域中。此时，派生类只需要定义其特有的函数就可以了，而无需为继承而来的其他函数重新定义。对派生类没有重新定义的重载版本的访问实际上是对 `using` 声明点的访问。

---

## References

《 C++ Primer 5 》
