---
title: C++ - virtual function
author: lambdaxing
date: 2020-10-8 17:16:00 +0800
categories: [Notes, Cpp]
tags: [Cpp]
---

## 简述

&emsp;&emsp;虚函数，用于定义类型特定行为的成员函数。  
&emsp;&emsp;在 c++ 语言中，基类将类型相关的函数与派生类不做改变直接继承的函数区分对待。基类希望它的派生类各自定义某些函数，使其适合自身，此时基类就将这些函数声明成虚函数。  
&emsp;&emsp;动态绑定只作用于虚函数，并且需要通过指针或引用调用。动态绑定在运行时根据引用或指针所绑定的对象的实际类型来选择执行虚函数的某一个版本。当我们通过一个具有普通类型（非引用非指针）的表达式调用虚函数时，在编译时就会将调用的版本确定下来。  
&emsp;&emsp;我们必须为每一个虚函数都提供定义，而不管它是否被用到了，这是因为连编译器也无法确定到底会使用哪个虚函数。  
&emsp;&emsp;基类中的虚函数在派生类中隐含地也是一个虚函数。当派生类覆盖了某个虚函数时，该函数在基类中的形参和返回类型必须与派生类中的形参和返回类型严格匹配。例外是，当类的虚函数返回类型是类本身的指针或引用，且从派生类到基类的类型转换是可访问的，该规则无效（仅返回类型）。

## `final` 和 `override` 说明符

&emsp;&emsp;如果派生类未覆盖其基类中的某个虚函数，则该虚函数会直接继承其在基类中的版本。派生类如果定义了一个函数与基类中的虚函数的名字相同但是形参列表不同，这任然合法，两个函数相互独立。在派生类中的成员函数参数列表后面添加关键字 `override`显式地注明使用该成员函数覆盖它继承的虚函数。我们还能通过将某个函数指定为 `final`，使得之后任何尝试覆盖该函数的操作都将引发错误。`final` 和 `override` 说明符出现在形参列表（包括任何`const` 关键字或引用限定符）以及尾置返回类型之后。

## 虚函数与默认实参

&emsp;&emsp;虚函数可以拥有默认实参，使用默认实参的虚函数调用的实参值由该次调用的静态类型决定。使用基类的引用和指针调用函数，则使用基类中定义的默认实参。如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致。

## 回避虚函数的机制

&emsp;&emsp;使用作用域运算符可以对虚函数的调用不进行动态绑定，强迫其执行虚函数的某个特定版本。这样的调用会在编译时完成解析。通常情况下，只有成员函数（或友元）中的代码才需要使用作用域运算符来回避虚函数的机制。

## 纯虚函数与抽象基类

&emsp;&emsp;通过在虚函数的声明语句的分号之前书写 `=0`将该虚函数声明为纯虚函数。`=0` 只能出现在类内部的虚函数声明语句处。我们可以为纯虚函数提供定义，函数体必须定义在类的外部。  
&emsp;&emsp;含有（或者未经覆盖直接继承）纯虚函数的类是抽象基类（abstract base class）。抽象基类负责定义接口，而后续的其他类可以覆盖该接口。不能直接创建一个抽象基类的对象。

---

## References

《 C++ Primer 5 》
